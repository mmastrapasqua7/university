# Protezione della confidenzialità dei dati su server di terze parti

Devo proteggere dati ma garantire funzionalità. Accesso a dati a granularità fine.

## Data confidentiality

Può essere basata su

- **encryption**

- **encryption e fragmentation**

- **fragmentation**

### Encryption

Il server può essere onesto ma curioso, è un nome che do al problema per proteggere i dati dal server stesso.

- Ma tanto i dati li cifro! NOPE

Posso crittare tutta la tabella, le colonne, le tuple, le celle. Ho granularità nel cifrare le cose. A livello di cella è troppo dispendioso. Devo crittare a livello di **tuple**. Se guardo i tradeoff tra tabella e cella, quella vincente è **cifratura di tupla**.

Mi serve un modo per fargli fare operazioni senza dargli chiave e senza dargli la possibilità di fare inferenze.

**RAMO PIU' ENCRYPTION**:

- Keyword base search, string matching. Ho un file crittato e voglio cercare tutti i file che contengono la stringa "Samarati". 

- Homomorphic encryption supporta l'operazione direttamente sui dati cifrati, senza dover portare a casa un intero file, decifrarlo e trovare

- Encryption schemas: ogni colonna la cifro con uno schema diverso dipendente dai valori. Esempio, posso cifrare valori in modo tale che un numero più basso corrisponde a una stringa di cifrazione minore

- Onion encryption: diversi strati di cifrazione, a cipolla come Tor. (**order preserving**)

- Indexes: si attaccano metadati ai dati. Ovvero si associano degli indici a dei dati
  
  Esempio: associo degli indici agli attributi

#### Indexes encryption

##### Direct (1:1)

Valore effettivo o codificato

- +semplice e preciso per query di uguaglianza: se voglio trovare tutti quelli che hanno x, chiedo: dammi tutte le tuple con indice x

- -preserva la distinguibilità dei valori, possibile attacco per inferenza e attacco per frequenza
  
  - esempio: ho 2 occorrenze di indici

##### Bucket (n:1)

Posso avere collisione. Valori diversi che si mappano sullo stesso indice (hash, partizionamento)

- +supporto per query di uguaglianza

- +la collisione rimuove la distinguibilità

- -il risultato può contenere più tuple di quelle che ho

- -vulnerabile ad attacchi per inferenza
  
  - esempio: se ho una certa frequenza del valore X, e ho bucket con frequenza minore della frequenza di X, allora escludo che siano li dentro

##### Flattened (1:n)

- +diminuisco l'esposizione ad attacchi per inferenza

- -rimane vulnerabile ad attacchi da osservatore
  
  se mappo uno stesso valore in valori di indici diversi, ogni volta che cerco quel valore devo cercare tutti gli altri indici. Esempio: ogni volta che chiedo il valore X, chiedo sempre gli stessi indici alpha beta gamma

#### Partition-based index

Considero un attributo arbitrario $A_i$ nello schema relazionale $R$ con dominio $D_i$.

$D_i$ è partizionato con un numero di sotto insiemi non intersecabili (partizioni), che contengono valori continui

Dato una tupla in plaintext $t$ in $r$, il valore dell'attributo $A_i$ per $t$ appartiene a una partizione

- $ident_{R.A_i}(p_j)$ assegna a ogni partizione $p_j$ dell'attributo $A_i$ in $R$ un identificatore

Il corrispondente valore di indice è l'unico valore associato alla partizione a cui il valore in plaintext $t[A_i]$ appartiene

- $Map_{R.A_i}(v) = ident_{R.A_i}(p_j)$ dove $p_j$ è la partizione che contiene $v$

$Map_{R.A_i}(v)$ può essere order-preserving o random

##### Condizioni supportate

- Attributo op Valore

- Attributo op Attributo

$op = \{=, \lt, \gt...\}$





... RECUPERARE ...





#### Hash-based Index

Basato sulla funzione one-way hash. Per ogni attributo $A_i$ in $R$ con dominio $D_i$ faccio un hash di tutti i valori del dominio. $h: D_i \to B_i$ che sarà il nuovo dominio dell'indice $I_i$ associato a $A_i$.

### Interval-based queries

I metodi di indicizzazione che preservano l'ordine sono soggetti ad attachi per inferenza. Se invece uso tecniche che non lo preservano non ho più attacchi ad inferenza ma non posso più fare query a intervalli, ovvero **range**.

Se uso la crittografia con indice non-order preserving, l'indice interno del database perde significato e le query sono lente.

### Order preserving encryption

- **OPES (Order Preserving Encryption Schema)** prende in input una distribuzione di valori di indice e applica la trasformazione order preserving così che i valori risultanti degli indici seguono la distribuzione.

- **OPESS (Order Preserving Encryption with Splitting and Scaling)**

### Fully homomorphic encryption

### Inference exposure

Se ci sono 2 requisiti in conflitto sull'indicizzazione dei dati

- gli indici devono provvedere un meccanismo efficente per eseguire query velocemente

- gli indici non devono aprire le porte ad attacchi di inferenza e di linking

**$\epsilon$ = Exposure Coefficient**

La computazione del coefficiente $\epsilon$ dipende da 2 fattori

- metodo di indicizzazione
  
  - direct encryption
  
  - hashing

- conoscenza a priori dell'intruso
  
  - Freq + DB$^k$
    
    - Freq è la distribuzione dei valori in plaintext del db originale
    
    - DB$^k$ è il database cifrato
    
    Guardando i valori di indici nella tabella cifrata e quel poco che so delle frequenze del plain text posso fare inferenza sul db cifrato. L'attacco si basa sul numero di occorrenze che si mappano sui valori di indice. **Protezione base**: tutti gli indici 1:1, oppure tutti hanno lo stesso numero di frequenze.
    
    - **classe di equivalenza** C è esposto $\frac{1}{|C|}$ come valore di esposizione $\epsilon$. I valori di indice con lo stesso valore di frequenza appartengono alla stessa classe. Quello che protegge i valori sono gli altri con lo stesso valore di frequenza
    
    **L'inversa cardinalità è sulla tupla, il quoziente è sulla cella**
  
  - DB + DB$^k$
    
    - DB in plain text
    
    - DB$^k$ cifrato
    
    Già so le tuple, ma devo proteggere la corrispondenza sennò tutti gli aggiornamenti e inserimenti sono esposti. Guardo al tabella, guardo l'indicizzazione.
    
    **Row-Column-Value GRAPH**. Il grafo ottenuto da questo metodo sarà identico sia in plaintext sia in testo cifrato. L'esposizione all'inferenza può essere misurata valutando l'automorfismo del grafo. Collegamento tra tuple

### Computing the inference exposure

Devo guardare il mapping tra un insieme di etichette del grafo all'altro che preserva la topologia. **equitable partitions**. Ogni sottoinsieme che appare nella partizione è un sottoinsieme che è equivalente a qualcun altro nel grafo precedente. La probabilità di identificare un vertice nella partizione è $\frac{1}{|C|}$

L'esposizione di equitable partitions di $n$ elementi sul totale di $m$ è $\frac{n}{m}$

## Bloom Filter

E' un metodo efficiente per verificare l'appartenenza a un insieme, set membership

- Ho un insieme di $n$ elementi ($n$ grande)

- Un vettore di $l$ bit ($l$ piccolo)

- $h$ funzioni hash indipendenti $H_i: \{0, 1\}^* \to [1, l]$

Quando inserisco l'elemento $x$

- Setto a 1 il bit all'indice ritornato dalla funzione $H_1(x), ..., H_h(x)$

Cerco l'elemento $x$

- Computo $H_1(x), ..., H_h(x)$ e cerco se questi valori sono settati nel vettore di bit $l$, ovvero se trovo i bit a 1

PRO:

- **Vantaggio: efficienza di spazio**, con 10 bit per elemento ho 1% probabilità errore

- Accettabile per applicazioni che hanno bisogno di efficienza nello spazio

CONTRO:

- **Problema del FALSO POSITIVO!** Le collisioni mi settano i bit, se uno coincide mi da un falso positivo.

- **NON POSSO RIMUOVERE ELEMENTO**

### Data integrity in outsourced data

L'integrità nello spazio di archiviazione deve essere protetto da modifiche improprie

- devo accorgermi di aggiornamenti non autorizzati

Integrità della computazione delle query

### Data integrity in storage

Si basa sulla firma digitale. Le firme sono computate a livello di tupla

- firme table e attribute level possono essere verificate solamente scaricando l'intera tabella/porzione di tabella

- a livello di cella c'è troppo overhead

Il costo di verifica aumenta linearmente col numero di tuple nel risultato

### Selective Encryption and Over-Encryption (aka CONTROLLO ACCESSO e AUTORIZZAZIONE)

Utenti diversi possono aver bisogno di diverse viste sui dati

Dobbiamo dare controllo all'utente che possiede i dati.

- **ABE** (Attribute Based Encryption) dipendono da una politica di accesso. Rendo possibile la derivazione della chiave solo agli utenti che possiedono certi attributi (asymmetric encryption). Serve un **reference monitor per l'autorizzazione**

- **Selective Encryption**: l'autorizzazione è tradotta in encryption vera e propria, ovvero cifro (asymmetric encryption) **No reference monitor: la stessa l'encryption è il reference monitor**

#### Selective Encryption

##### Authorization policy

DAC policy per regolare l'accesso in lettura alle risorse

La più primitiva la posso implementare come

- matrice di accesso (soggetto, oggetto) con 0 e 1 dove 1 è la lettura
  
  - anche rappresentabile come un grafo diretto bipartito di accesso
  
  Tipicamente la matrice viene salvata con
  
  - (**ACL**) indicizzazione per colonna, ovvero per ciascun oggetto ho la lista dei soggetti a cui possono accedere, oppure
  
  - (**CAPABILITY**) indicizzazione per riga, ovvero per ciascun soggetto ho la lista di oggetti a cui può accedere

##### Encryption policy

La policy di autorizzazione definita dal proprietario dei dati deve essere tradotta in una encryption policy equivalente

- Cifro ogni risorsa nel sistema e do le chiavi a chi può accedere
  
  - -richiede all'utente di dare le chiavi per ogni oggetto a cui ha accesso

- Uso un modello di derivazione della chiave cosi che può derivare le chiavi che gli servono

###### Key derivation methods

La conoscenza di chiave di un nodo ti porta alla conoscenza di tutte le altre chiavi sotto di essa in gerarchia. Può essere rappresentata come un grafo

###### Token-based derivation methods

Ho chiavi e token. Per ogni chiave ho un token. La cosa è direzionale, posso derivare solo verso un senso e non al contrario

###### Translating: Exploiting ACL

Mi permette di raggruppare utenti con lo stesso privilegio. L'insieme poi esplode col numero degli utenti diventando $2^U-1$, dove U è il numero di utenti. Ma partendo da questo posso eliminare tutto quello che sta nel mezzo tra utenti e risorse, ovvero chiavi che non cifrano nulla.
